pub use crate::jmorecfg_h::boolean;
pub use crate::jmorecfg_h::FALSE;
pub use crate::jmorecfg_h::JCOEF;
pub use crate::jmorecfg_h::JDIMENSION;
pub use crate::jmorecfg_h::JOCTET;
pub use crate::jmorecfg_h::JSAMPLE;
pub use crate::jmorecfg_h::MAX_COMPONENTS;
pub use crate::jmorecfg_h::TRUE;
pub use crate::jmorecfg_h::UINT16;
pub use crate::jmorecfg_h::UINT8;
pub use crate::jpeglib_h::j_common_ptr;
pub use crate::jpeglib_h::j_compress_ptr;
pub use crate::jpeglib_h::jpeg_add_quant_table;
pub use crate::jpeglib_h::jpeg_c_coef_controller;
pub use crate::jpeglib_h::jpeg_c_get_int_param;
pub use crate::jpeglib_h::jpeg_c_int_param_supported;
pub use crate::jpeglib_h::jpeg_c_main_controller;
pub use crate::jpeglib_h::jpeg_c_prep_controller;
pub use crate::jpeglib_h::jpeg_c_set_bool_param;
pub use crate::jpeglib_h::jpeg_color_converter;
pub use crate::jpeglib_h::jpeg_common_struct;
pub use crate::jpeglib_h::jpeg_comp_master;
pub use crate::jpeglib_h::jpeg_component_info;
pub use crate::jpeglib_h::jpeg_compress_struct;
pub use crate::jpeglib_h::jpeg_destination_mgr;
pub use crate::jpeglib_h::jpeg_downsampler;
pub use crate::jpeglib_h::jpeg_entropy_encoder;
pub use crate::jpeglib_h::jpeg_error_mgr;
pub use crate::jpeglib_h::jpeg_float_quality_scaling;
pub use crate::jpeglib_h::jpeg_forward_dct;
pub use crate::jpeglib_h::jpeg_marker_writer;
pub use crate::jpeglib_h::jpeg_memory_mgr;
pub use crate::jpeglib_h::jpeg_progress_mgr;
pub use crate::jpeglib_h::jpeg_scan_info;
pub use crate::jpeglib_h::jvirt_barray_control;
pub use crate::jpeglib_h::jvirt_barray_ptr;
pub use crate::jpeglib_h::jvirt_sarray_control;
pub use crate::jpeglib_h::jvirt_sarray_ptr;
pub use crate::jpeglib_h::C2RustUnnamed_2;
pub use crate::jpeglib_h::JCS_YCbCr;
pub use crate::jpeglib_h::DCTSIZE2;
pub use crate::jpeglib_h::JBLOCK;
pub use crate::jpeglib_h::JBLOCKARRAY;
pub use crate::jpeglib_h::JBLOCKROW;
pub use crate::jpeglib_h::JBOOLEAN_OPTIMIZE_SCANS;
pub use crate::jpeglib_h::JBOOLEAN_OVERSHOOT_DERINGING;
pub use crate::jpeglib_h::JBOOLEAN_TRELLIS_EOB_OPT;
pub use crate::jpeglib_h::JBOOLEAN_TRELLIS_QUANT;
pub use crate::jpeglib_h::JBOOLEAN_TRELLIS_QUANT_DC;
pub use crate::jpeglib_h::JBOOLEAN_TRELLIS_Q_OPT;
pub use crate::jpeglib_h::JBOOLEAN_USE_LAMBDA_WEIGHT_TBL;
pub use crate::jpeglib_h::JBOOLEAN_USE_SCANS_IN_TRELLIS;
pub use crate::jpeglib_h::JCS_CMYK;
pub use crate::jpeglib_h::JCS_EXT_ABGR;
pub use crate::jpeglib_h::JCS_EXT_ARGB;
pub use crate::jpeglib_h::JCS_EXT_BGR;
pub use crate::jpeglib_h::JCS_EXT_BGRA;
pub use crate::jpeglib_h::JCS_EXT_BGRX;
pub use crate::jpeglib_h::JCS_EXT_RGB;
pub use crate::jpeglib_h::JCS_EXT_RGBA;
pub use crate::jpeglib_h::JCS_EXT_RGBX;
pub use crate::jpeglib_h::JCS_EXT_XBGR;
pub use crate::jpeglib_h::JCS_EXT_XRGB;
pub use crate::jpeglib_h::JCS_GRAYSCALE;
pub use crate::jpeglib_h::JCS_RGB;
pub use crate::jpeglib_h::JCS_RGB565;
pub use crate::jpeglib_h::JCS_UNKNOWN;
pub use crate::jpeglib_h::JCS_YCCK;
pub use crate::jpeglib_h::JDCT_FLOAT;
pub use crate::jpeglib_h::JDCT_IFAST;
pub use crate::jpeglib_h::JDCT_ISLOW;
pub use crate::jpeglib_h::JHUFF_TBL;
pub use crate::jpeglib_h::JINT_BASE_QUANT_TBL_IDX;
pub use crate::jpeglib_h::JINT_COMPRESS_PROFILE;
pub use crate::jpeglib_h::JINT_DC_SCAN_OPT_MODE;
pub use crate::jpeglib_h::JINT_TRELLIS_FREQ_SPLIT;
pub use crate::jpeglib_h::JINT_TRELLIS_NUM_LOOPS;
pub use crate::jpeglib_h::JPOOL_IMAGE;
pub use crate::jpeglib_h::JQUANT_TBL;
pub use crate::jpeglib_h::JSAMPARRAY;
pub use crate::jpeglib_h::JSAMPROW;
pub use crate::jpeglib_h::J_BOOLEAN_PARAM;
pub use crate::jpeglib_h::J_COLOR_SPACE;
pub use crate::jpeglib_h::J_DCT_METHOD;
pub use crate::jpeglib_h::J_INT_PARAM;
pub use crate::jpeglib_h::MAX_COMPS_IN_SCAN;
pub use crate::jpeglib_h::NUM_QUANT_TBLS;
pub use crate::stddef_h::size_t;
pub use crate::stddef_h::NULL;
pub use crate::stdlib::C2RustUnnamed_0;
pub use crate::stdlib::_IO_codecvt;
pub use crate::stdlib::_IO_lock_t;
pub use crate::stdlib::_IO_marker;
pub use crate::stdlib::_IO_wide_data;
pub use crate::stdlib::_ISalnum;
pub use crate::stdlib::_ISalpha;
pub use crate::stdlib::_ISblank;
pub use crate::stdlib::_IScntrl;
pub use crate::stdlib::_ISdigit;
pub use crate::stdlib::_ISgraph;
pub use crate::stdlib::_ISlower;
pub use crate::stdlib::_ISprint;
pub use crate::stdlib::_ISpunct;
pub use crate::stdlib::_ISspace;
pub use crate::stdlib::_ISupper;
pub use crate::stdlib::_ISxdigit;
pub use crate::stdlib::__ctype_b_loc;
pub use crate::stdlib::__off64_t;
pub use crate::stdlib::__off_t;
pub use crate::stdlib::fclose;
pub use crate::stdlib::fopen;
pub use crate::stdlib::fprintf;
pub use crate::stdlib::getc;
use crate::stdlib::memcpy;
pub use crate::stdlib::sscanf;
pub use crate::stdlib::stderr;
pub use crate::stdlib::ungetc;
pub use crate::stdlib::EOF;
pub use crate::stdlib::FILE;
pub use crate::stdlib::_IO_FILE;
use libc;
use libc::c_char;
use libc::c_float;
use libc::c_int;
use libc::c_long;
use libc::c_uint;
use libc::c_ulong;
use libc::c_ushort;
use libc::c_void;
/*
 * rdswitch.c
 *
 * This file was part of the Independent JPEG Group's software:
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * libjpeg-turbo Modifications:
 * Copyright (C) 2010, 2018, D. R. Commander.
 * For conditions of distribution and use, see the accompanying README.ijg
 * file.
 *
 * This file contains routines to process some of cjpeg's more complicated
 * command-line switches.  Switches processed here are:
 *      -qtables file           Read quantization tables from text file
 *      -scans file             Read scan script from text file
 *      -quality N[,N,...]      Set quality ratings
 *      -qslots N[,N,...]       Set component quantization table selectors
 *      -sample HxV[,HxV,...]   Set component sampling factors
 */
/* to declare isdigit(), isspace() */
unsafe extern "C" fn text_getc(mut file: *mut FILE) -> c_int {
    let mut ch: c_int = 0;
    ch = getc(file);
    if ch == '#' as i32 {
        loop {
            ch = getc(file);
            if !(ch != '\n' as i32 && ch != EOF) {
                break;
            }
        }
    }
    return ch;
}
unsafe extern "C" fn read_text_integer(
    mut file: *mut FILE,
    mut result: *mut c_long,
    mut termchar: *mut c_int,
) -> boolean {
    let mut ch: c_int = 0;
    let mut val: c_long = 0;
    loop {
        ch = text_getc(file);
        if ch == EOF {
            *termchar = ch;
            return FALSE;
        }
        if !(0
            != *(*__ctype_b_loc()).offset(ch as isize) as c_int
                & _ISspace as c_int as c_ushort as c_int)
        {
            break;
        }
    }
    if 0 == *(*__ctype_b_loc()).offset(ch as isize) as c_int
        & _ISdigit as c_int as c_ushort as c_int
    {
        *termchar = ch;
        return FALSE;
    }
    val = (ch - '0' as i32) as c_long;
    loop {
        ch = text_getc(file);
        if !(ch != EOF) {
            break;
        }
        if 0 == *(*__ctype_b_loc()).offset(ch as isize) as c_int
            & _ISdigit as c_int as c_ushort as c_int
        {
            break;
        }
        val *= 10i32 as c_long;
        val += (ch - '0' as i32) as c_long
    }
    *result = val;
    *termchar = ch;
    return TRUE;
}
static mut q_scale_factor: [c_int; 4] = [100i32, 100i32, 100i32, 100i32];
/* cjpeg support routines (in rdswitch.c) */
#[no_mangle]
pub unsafe extern "C" fn read_quant_tables(
    mut cinfo: j_compress_ptr,
    mut filename: *mut c_char,
    mut force_baseline: boolean,
) -> boolean {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut tblno: c_int = 0;
    let mut i: c_int = 0;
    let mut termchar: c_int = 0;
    let mut val: c_long = 0;
    let mut table: [c_uint; 64] = [0; 64];
    fp = fopen(filename, b"r\x00" as *const u8 as *const c_char);
    if fp.is_null() {
        fprintf(
            stderr,
            b"Can\'t open table file %s\n\x00" as *const u8 as *const c_char,
            filename,
        );
        return FALSE;
    }
    tblno = 0i32;
    while 0 != read_text_integer(fp, &mut val, &mut termchar) {
        if tblno >= NUM_QUANT_TBLS {
            fprintf(
                stderr,
                b"Too many tables in file %s\n\x00" as *const u8 as *const c_char,
                filename,
            );
            fclose(fp);
            return FALSE;
        }
        table[0usize] = val as c_uint;
        i = 1i32;
        while i < DCTSIZE2 {
            if 0 == read_text_integer(fp, &mut val, &mut termchar) {
                fprintf(
                    stderr,
                    b"Invalid table data in file %s\n\x00" as *const u8 as *const c_char,
                    filename,
                );
                fclose(fp);
                return FALSE;
            }
            table[i as usize] = val as c_uint;
            i += 1
        }
        jpeg_add_quant_table(
            cinfo,
            tblno,
            table.as_mut_ptr(),
            q_scale_factor[tblno as usize],
            force_baseline,
        );
        tblno += 1
    }
    if termchar != EOF {
        fprintf(
            stderr,
            b"Non-numeric data in file %s\n\x00" as *const u8 as *const c_char,
            filename,
        );
        fclose(fp);
        return FALSE;
    }
    fclose(fp);
    return TRUE;
}
unsafe extern "C" fn read_scan_integer(
    mut file: *mut FILE,
    mut result: *mut c_long,
    mut termchar: *mut c_int,
) -> boolean {
    let mut ch: c_int = 0;
    if 0 == read_text_integer(file, result, termchar) {
        return FALSE;
    }
    ch = *termchar;
    while ch != EOF
        && 0 != *(*__ctype_b_loc()).offset(ch as isize) as c_int
            & _ISspace as c_int as c_ushort as c_int
    {
        ch = text_getc(file)
    }
    if 0 != *(*__ctype_b_loc()).offset(ch as isize) as c_int
        & _ISdigit as c_int as c_ushort as c_int
    {
        if ungetc(ch, file) == EOF {
            return FALSE;
        }
        ch = ' ' as i32
    } else if ch != EOF && ch != ';' as i32 && ch != ':' as i32 {
        ch = ' ' as i32
    }
    *termchar = ch;
    return TRUE;
}
#[no_mangle]
pub unsafe extern "C" fn read_scan_script(
    mut cinfo: j_compress_ptr,
    mut filename: *mut c_char,
) -> boolean {
    let mut current_block: u64;
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut scanno: c_int = 0;
    let mut ncomps: c_int = 0;
    let mut termchar: c_int = 0;
    let mut val: c_long = 0;
    let mut scanptr: *mut jpeg_scan_info = 0 as *mut jpeg_scan_info;
    let mut scans: [jpeg_scan_info; 100] = [jpeg_scan_info {
        comps_in_scan: 0,
        component_index: [0; 4],
        Ss: 0,
        Se: 0,
        Ah: 0,
        Al: 0,
    }; 100];
    fp = fopen(filename, b"r\x00" as *const u8 as *const c_char);
    if fp.is_null() {
        fprintf(
            stderr,
            b"Can\'t open scan definition file %s\n\x00" as *const u8 as *const c_char,
            filename,
        );
        return FALSE;
    }
    scanptr = scans.as_mut_ptr();
    scanno = 0i32;
    while 0 != read_scan_integer(fp, &mut val, &mut termchar) {
        if scanno >= MAX_SCANS {
            fprintf(
                stderr,
                b"Too many scans defined in file %s\n\x00" as *const u8 as *const c_char,
                filename,
            );
            fclose(fp);
            return FALSE;
        }
        (*scanptr).component_index[0usize] = val as c_int;
        ncomps = 1i32;
        loop {
            if !(termchar == ' ' as i32) {
                current_block = 1109700713171191020;
                break;
            }
            if ncomps >= MAX_COMPS_IN_SCAN {
                fprintf(
                    stderr,
                    b"Too many components in one scan in file %s\n\x00" as *const u8
                        as *const c_char,
                    filename,
                );
                fclose(fp);
                return FALSE;
            }
            if 0 == read_scan_integer(fp, &mut val, &mut termchar) {
                current_block = 9520589643232431964;
                break;
            }
            (*scanptr).component_index[ncomps as usize] = val as c_int;
            ncomps += 1
        }
        match current_block {
            1109700713171191020 => {
                (*scanptr).comps_in_scan = ncomps;
                if termchar == ':' as i32 {
                    if 0 == read_scan_integer(fp, &mut val, &mut termchar) || termchar != ' ' as i32
                    {
                        current_block = 9520589643232431964;
                    } else {
                        (*scanptr).Ss = val as c_int;
                        if 0 == read_scan_integer(fp, &mut val, &mut termchar)
                            || termchar != ' ' as i32
                        {
                            current_block = 9520589643232431964;
                        } else {
                            (*scanptr).Se = val as c_int;
                            if 0 == read_scan_integer(fp, &mut val, &mut termchar)
                                || termchar != ' ' as i32
                            {
                                current_block = 9520589643232431964;
                            } else {
                                (*scanptr).Ah = val as c_int;
                                if 0 == read_scan_integer(fp, &mut val, &mut termchar) {
                                    current_block = 9520589643232431964;
                                } else {
                                    (*scanptr).Al = val as c_int;
                                    current_block = 8845338526596852646;
                                }
                            }
                        }
                    }
                } else {
                    (*scanptr).Ss = 0i32;
                    (*scanptr).Se = DCTSIZE2 - 1i32;
                    (*scanptr).Ah = 0i32;
                    (*scanptr).Al = 0i32;
                    current_block = 8845338526596852646;
                }
                match current_block {
                    9520589643232431964 => {}
                    _ => {
                        if !(termchar != ';' as i32 && termchar != EOF) {
                            scanptr = scanptr.offset(1isize);
                            scanno += 1;
                            continue;
                        }
                    }
                }
            }
            _ => {}
        }
        fprintf(
            stderr,
            b"Invalid scan entry format in file %s\n\x00" as *const u8 as *const c_char,
            filename,
        );
        fclose(fp);
        return FALSE;
    }
    if termchar != EOF {
        fprintf(
            stderr,
            b"Non-numeric data in file %s\n\x00" as *const u8 as *const c_char,
            filename,
        );
        fclose(fp);
        return FALSE;
    }
    if scanno > 0i32 {
        scanptr = (*(*cinfo).mem)
            .alloc_small
            .expect("non-null function pointer")(
            cinfo as j_common_ptr,
            JPOOL_IMAGE,
            (scanno as c_ulong).wrapping_mul(::std::mem::size_of::<jpeg_scan_info>() as c_ulong),
        ) as *mut jpeg_scan_info;
        memcpy(
            scanptr as *mut c_void,
            scans.as_mut_ptr() as *const c_void,
            (scanno as c_ulong).wrapping_mul(::std::mem::size_of::<jpeg_scan_info>() as c_ulong),
        );
        (*cinfo).scan_info = scanptr;
        (*cinfo).num_scans = scanno;
        jpeg_c_set_bool_param(cinfo, JBOOLEAN_OPTIMIZE_SCANS, FALSE);
    }
    fclose(fp);
    return TRUE;
}
/* quite arbitrary limit */
pub const MAX_SCANS: c_int = 100i32;
/* C_MULTISCAN_FILES_SUPPORTED */
/* These are the sample quantization tables given in Annex K (Clause K.1) of
 * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.
 * The spec says that the values given produce "good" quality, and
 * when divided by 2, "very good" quality.
 */
static mut std_luminance_quant_tbl: [[c_uint; 64]; 9] = [
    [
        16i32 as c_uint,
        11i32 as c_uint,
        10i32 as c_uint,
        16i32 as c_uint,
        24i32 as c_uint,
        40i32 as c_uint,
        51i32 as c_uint,
        61i32 as c_uint,
        12i32 as c_uint,
        12i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        26i32 as c_uint,
        58i32 as c_uint,
        60i32 as c_uint,
        55i32 as c_uint,
        14i32 as c_uint,
        13i32 as c_uint,
        16i32 as c_uint,
        24i32 as c_uint,
        40i32 as c_uint,
        57i32 as c_uint,
        69i32 as c_uint,
        56i32 as c_uint,
        14i32 as c_uint,
        17i32 as c_uint,
        22i32 as c_uint,
        29i32 as c_uint,
        51i32 as c_uint,
        87i32 as c_uint,
        80i32 as c_uint,
        62i32 as c_uint,
        18i32 as c_uint,
        22i32 as c_uint,
        37i32 as c_uint,
        56i32 as c_uint,
        68i32 as c_uint,
        109i32 as c_uint,
        103i32 as c_uint,
        77i32 as c_uint,
        24i32 as c_uint,
        35i32 as c_uint,
        55i32 as c_uint,
        64i32 as c_uint,
        81i32 as c_uint,
        104i32 as c_uint,
        113i32 as c_uint,
        92i32 as c_uint,
        49i32 as c_uint,
        64i32 as c_uint,
        78i32 as c_uint,
        87i32 as c_uint,
        103i32 as c_uint,
        121i32 as c_uint,
        120i32 as c_uint,
        101i32 as c_uint,
        72i32 as c_uint,
        92i32 as c_uint,
        95i32 as c_uint,
        98i32 as c_uint,
        112i32 as c_uint,
        100i32 as c_uint,
        103i32 as c_uint,
        99i32 as c_uint,
    ],
    [
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
    ],
    [
        12i32 as c_uint,
        17i32 as c_uint,
        20i32 as c_uint,
        21i32 as c_uint,
        30i32 as c_uint,
        34i32 as c_uint,
        56i32 as c_uint,
        63i32 as c_uint,
        18i32 as c_uint,
        20i32 as c_uint,
        20i32 as c_uint,
        26i32 as c_uint,
        28i32 as c_uint,
        51i32 as c_uint,
        61i32 as c_uint,
        55i32 as c_uint,
        19i32 as c_uint,
        20i32 as c_uint,
        21i32 as c_uint,
        26i32 as c_uint,
        33i32 as c_uint,
        58i32 as c_uint,
        69i32 as c_uint,
        55i32 as c_uint,
        26i32 as c_uint,
        26i32 as c_uint,
        26i32 as c_uint,
        30i32 as c_uint,
        46i32 as c_uint,
        87i32 as c_uint,
        86i32 as c_uint,
        66i32 as c_uint,
        31i32 as c_uint,
        33i32 as c_uint,
        36i32 as c_uint,
        40i32 as c_uint,
        46i32 as c_uint,
        96i32 as c_uint,
        100i32 as c_uint,
        73i32 as c_uint,
        40i32 as c_uint,
        35i32 as c_uint,
        46i32 as c_uint,
        62i32 as c_uint,
        81i32 as c_uint,
        100i32 as c_uint,
        111i32 as c_uint,
        91i32 as c_uint,
        46i32 as c_uint,
        66i32 as c_uint,
        76i32 as c_uint,
        86i32 as c_uint,
        102i32 as c_uint,
        121i32 as c_uint,
        120i32 as c_uint,
        101i32 as c_uint,
        68i32 as c_uint,
        90i32 as c_uint,
        90i32 as c_uint,
        96i32 as c_uint,
        113i32 as c_uint,
        102i32 as c_uint,
        105i32 as c_uint,
        103i32 as c_uint,
    ],
    [
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        18i32 as c_uint,
        25i32 as c_uint,
        37i32 as c_uint,
        56i32 as c_uint,
        85i32 as c_uint,
        16i32 as c_uint,
        17i32 as c_uint,
        20i32 as c_uint,
        27i32 as c_uint,
        34i32 as c_uint,
        40i32 as c_uint,
        53i32 as c_uint,
        75i32 as c_uint,
        16i32 as c_uint,
        20i32 as c_uint,
        24i32 as c_uint,
        31i32 as c_uint,
        43i32 as c_uint,
        62i32 as c_uint,
        91i32 as c_uint,
        135i32 as c_uint,
        18i32 as c_uint,
        27i32 as c_uint,
        31i32 as c_uint,
        40i32 as c_uint,
        53i32 as c_uint,
        74i32 as c_uint,
        106i32 as c_uint,
        156i32 as c_uint,
        25i32 as c_uint,
        34i32 as c_uint,
        43i32 as c_uint,
        53i32 as c_uint,
        69i32 as c_uint,
        94i32 as c_uint,
        131i32 as c_uint,
        189i32 as c_uint,
        37i32 as c_uint,
        40i32 as c_uint,
        62i32 as c_uint,
        74i32 as c_uint,
        94i32 as c_uint,
        124i32 as c_uint,
        169i32 as c_uint,
        238i32 as c_uint,
        56i32 as c_uint,
        53i32 as c_uint,
        91i32 as c_uint,
        106i32 as c_uint,
        131i32 as c_uint,
        169i32 as c_uint,
        226i32 as c_uint,
        311i32 as c_uint,
        85i32 as c_uint,
        75i32 as c_uint,
        135i32 as c_uint,
        156i32 as c_uint,
        189i32 as c_uint,
        238i32 as c_uint,
        311i32 as c_uint,
        418i32 as c_uint,
    ],
    [
        9i32 as c_uint,
        10i32 as c_uint,
        12i32 as c_uint,
        14i32 as c_uint,
        27i32 as c_uint,
        32i32 as c_uint,
        51i32 as c_uint,
        62i32 as c_uint,
        11i32 as c_uint,
        12i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        27i32 as c_uint,
        44i32 as c_uint,
        59i32 as c_uint,
        73i32 as c_uint,
        12i32 as c_uint,
        14i32 as c_uint,
        18i32 as c_uint,
        25i32 as c_uint,
        42i32 as c_uint,
        59i32 as c_uint,
        79i32 as c_uint,
        78i32 as c_uint,
        17i32 as c_uint,
        18i32 as c_uint,
        25i32 as c_uint,
        42i32 as c_uint,
        61i32 as c_uint,
        92i32 as c_uint,
        87i32 as c_uint,
        92i32 as c_uint,
        23i32 as c_uint,
        28i32 as c_uint,
        42i32 as c_uint,
        75i32 as c_uint,
        79i32 as c_uint,
        112i32 as c_uint,
        112i32 as c_uint,
        99i32 as c_uint,
        40i32 as c_uint,
        42i32 as c_uint,
        59i32 as c_uint,
        84i32 as c_uint,
        88i32 as c_uint,
        124i32 as c_uint,
        132i32 as c_uint,
        111i32 as c_uint,
        42i32 as c_uint,
        64i32 as c_uint,
        78i32 as c_uint,
        95i32 as c_uint,
        105i32 as c_uint,
        126i32 as c_uint,
        125i32 as c_uint,
        99i32 as c_uint,
        70i32 as c_uint,
        75i32 as c_uint,
        100i32 as c_uint,
        102i32 as c_uint,
        116i32 as c_uint,
        100i32 as c_uint,
        107i32 as c_uint,
        98i32 as c_uint,
    ],
    [
        10i32 as c_uint,
        12i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        26i32 as c_uint,
        38i32 as c_uint,
        57i32 as c_uint,
        86i32 as c_uint,
        12i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        28i32 as c_uint,
        35i32 as c_uint,
        41i32 as c_uint,
        54i32 as c_uint,
        76i32 as c_uint,
        14i32 as c_uint,
        21i32 as c_uint,
        25i32 as c_uint,
        32i32 as c_uint,
        44i32 as c_uint,
        63i32 as c_uint,
        92i32 as c_uint,
        136i32 as c_uint,
        19i32 as c_uint,
        28i32 as c_uint,
        32i32 as c_uint,
        41i32 as c_uint,
        54i32 as c_uint,
        75i32 as c_uint,
        107i32 as c_uint,
        157i32 as c_uint,
        26i32 as c_uint,
        35i32 as c_uint,
        44i32 as c_uint,
        54i32 as c_uint,
        70i32 as c_uint,
        95i32 as c_uint,
        132i32 as c_uint,
        190i32 as c_uint,
        38i32 as c_uint,
        41i32 as c_uint,
        63i32 as c_uint,
        75i32 as c_uint,
        95i32 as c_uint,
        125i32 as c_uint,
        170i32 as c_uint,
        239i32 as c_uint,
        57i32 as c_uint,
        54i32 as c_uint,
        92i32 as c_uint,
        107i32 as c_uint,
        132i32 as c_uint,
        170i32 as c_uint,
        227i32 as c_uint,
        312i32 as c_uint,
        86i32 as c_uint,
        76i32 as c_uint,
        136i32 as c_uint,
        157i32 as c_uint,
        190i32 as c_uint,
        239i32 as c_uint,
        312i32 as c_uint,
        419i32 as c_uint,
    ],
    [
        7i32 as c_uint,
        8i32 as c_uint,
        10i32 as c_uint,
        14i32 as c_uint,
        23i32 as c_uint,
        44i32 as c_uint,
        95i32 as c_uint,
        241i32 as c_uint,
        8i32 as c_uint,
        8i32 as c_uint,
        11i32 as c_uint,
        15i32 as c_uint,
        25i32 as c_uint,
        47i32 as c_uint,
        102i32 as c_uint,
        255i32 as c_uint,
        10i32 as c_uint,
        11i32 as c_uint,
        13i32 as c_uint,
        19i32 as c_uint,
        31i32 as c_uint,
        58i32 as c_uint,
        127i32 as c_uint,
        255i32 as c_uint,
        14i32 as c_uint,
        15i32 as c_uint,
        19i32 as c_uint,
        27i32 as c_uint,
        44i32 as c_uint,
        83i32 as c_uint,
        181i32 as c_uint,
        255i32 as c_uint,
        23i32 as c_uint,
        25i32 as c_uint,
        31i32 as c_uint,
        44i32 as c_uint,
        72i32 as c_uint,
        136i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        44i32 as c_uint,
        47i32 as c_uint,
        58i32 as c_uint,
        83i32 as c_uint,
        136i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        95i32 as c_uint,
        102i32 as c_uint,
        127i32 as c_uint,
        181i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        241i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
    ],
    [
        15i32 as c_uint,
        11i32 as c_uint,
        11i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        19i32 as c_uint,
        25i32 as c_uint,
        32i32 as c_uint,
        11i32 as c_uint,
        13i32 as c_uint,
        10i32 as c_uint,
        10i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        19i32 as c_uint,
        24i32 as c_uint,
        11i32 as c_uint,
        10i32 as c_uint,
        14i32 as c_uint,
        14i32 as c_uint,
        16i32 as c_uint,
        18i32 as c_uint,
        22i32 as c_uint,
        27i32 as c_uint,
        12i32 as c_uint,
        10i32 as c_uint,
        14i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        24i32 as c_uint,
        28i32 as c_uint,
        33i32 as c_uint,
        15i32 as c_uint,
        12i32 as c_uint,
        16i32 as c_uint,
        21i32 as c_uint,
        26i32 as c_uint,
        31i32 as c_uint,
        36i32 as c_uint,
        42i32 as c_uint,
        19i32 as c_uint,
        15i32 as c_uint,
        18i32 as c_uint,
        24i32 as c_uint,
        31i32 as c_uint,
        38i32 as c_uint,
        45i32 as c_uint,
        53i32 as c_uint,
        25i32 as c_uint,
        19i32 as c_uint,
        22i32 as c_uint,
        28i32 as c_uint,
        36i32 as c_uint,
        45i32 as c_uint,
        55i32 as c_uint,
        65i32 as c_uint,
        32i32 as c_uint,
        24i32 as c_uint,
        27i32 as c_uint,
        33i32 as c_uint,
        42i32 as c_uint,
        53i32 as c_uint,
        65i32 as c_uint,
        77i32 as c_uint,
    ],
    [
        14i32 as c_uint,
        10i32 as c_uint,
        11i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        25i32 as c_uint,
        34i32 as c_uint,
        45i32 as c_uint,
        10i32 as c_uint,
        11i32 as c_uint,
        11i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        20i32 as c_uint,
        26i32 as c_uint,
        33i32 as c_uint,
        11i32 as c_uint,
        11i32 as c_uint,
        15i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        25i32 as c_uint,
        31i32 as c_uint,
        38i32 as c_uint,
        14i32 as c_uint,
        12i32 as c_uint,
        18i32 as c_uint,
        24i32 as c_uint,
        28i32 as c_uint,
        33i32 as c_uint,
        39i32 as c_uint,
        47i32 as c_uint,
        19i32 as c_uint,
        15i32 as c_uint,
        21i32 as c_uint,
        28i32 as c_uint,
        36i32 as c_uint,
        43i32 as c_uint,
        51i32 as c_uint,
        59i32 as c_uint,
        25i32 as c_uint,
        20i32 as c_uint,
        25i32 as c_uint,
        33i32 as c_uint,
        43i32 as c_uint,
        54i32 as c_uint,
        64i32 as c_uint,
        74i32 as c_uint,
        34i32 as c_uint,
        26i32 as c_uint,
        31i32 as c_uint,
        39i32 as c_uint,
        51i32 as c_uint,
        64i32 as c_uint,
        77i32 as c_uint,
        91i32 as c_uint,
        45i32 as c_uint,
        33i32 as c_uint,
        38i32 as c_uint,
        47i32 as c_uint,
        59i32 as c_uint,
        74i32 as c_uint,
        91i32 as c_uint,
        108i32 as c_uint,
    ],
];
/* JPEG Annex K
 */
/* flat
 */
/* From http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008
 */
/* Relevance of human vision to JPEG-DCT compression (1992) Klein, Silverstein and Carney.
 */
/* DCTune perceptual optimization of compressed dental X-Rays (1997) Watson, Taylor, Borthwick
 */
/* A visual detection model for DCT coefficient quantization (12/9/93) Ahumada, Watson, Peterson
 */
/* An improved detection model for DCT coefficient quantization (1993) Peterson, Ahumada and Watson
 */
static mut std_chrominance_quant_tbl: [[c_uint; 64]; 9] = [
    [
        17i32 as c_uint,
        18i32 as c_uint,
        24i32 as c_uint,
        47i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        26i32 as c_uint,
        66i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        24i32 as c_uint,
        26i32 as c_uint,
        56i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        47i32 as c_uint,
        66i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
    ],
    [
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
    ],
    [
        8i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        15i32 as c_uint,
        86i32 as c_uint,
        96i32 as c_uint,
        96i32 as c_uint,
        98i32 as c_uint,
        13i32 as c_uint,
        13i32 as c_uint,
        15i32 as c_uint,
        26i32 as c_uint,
        90i32 as c_uint,
        96i32 as c_uint,
        99i32 as c_uint,
        98i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        18i32 as c_uint,
        96i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        17i32 as c_uint,
        16i32 as c_uint,
        90i32 as c_uint,
        96i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        96i32 as c_uint,
        96i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
    ],
    [
        16i32 as c_uint,
        16i32 as c_uint,
        16i32 as c_uint,
        18i32 as c_uint,
        25i32 as c_uint,
        37i32 as c_uint,
        56i32 as c_uint,
        85i32 as c_uint,
        16i32 as c_uint,
        17i32 as c_uint,
        20i32 as c_uint,
        27i32 as c_uint,
        34i32 as c_uint,
        40i32 as c_uint,
        53i32 as c_uint,
        75i32 as c_uint,
        16i32 as c_uint,
        20i32 as c_uint,
        24i32 as c_uint,
        31i32 as c_uint,
        43i32 as c_uint,
        62i32 as c_uint,
        91i32 as c_uint,
        135i32 as c_uint,
        18i32 as c_uint,
        27i32 as c_uint,
        31i32 as c_uint,
        40i32 as c_uint,
        53i32 as c_uint,
        74i32 as c_uint,
        106i32 as c_uint,
        156i32 as c_uint,
        25i32 as c_uint,
        34i32 as c_uint,
        43i32 as c_uint,
        53i32 as c_uint,
        69i32 as c_uint,
        94i32 as c_uint,
        131i32 as c_uint,
        189i32 as c_uint,
        37i32 as c_uint,
        40i32 as c_uint,
        62i32 as c_uint,
        74i32 as c_uint,
        94i32 as c_uint,
        124i32 as c_uint,
        169i32 as c_uint,
        238i32 as c_uint,
        56i32 as c_uint,
        53i32 as c_uint,
        91i32 as c_uint,
        106i32 as c_uint,
        131i32 as c_uint,
        169i32 as c_uint,
        226i32 as c_uint,
        311i32 as c_uint,
        85i32 as c_uint,
        75i32 as c_uint,
        135i32 as c_uint,
        156i32 as c_uint,
        189i32 as c_uint,
        238i32 as c_uint,
        311i32 as c_uint,
        418i32 as c_uint,
    ],
    [
        9i32 as c_uint,
        10i32 as c_uint,
        17i32 as c_uint,
        19i32 as c_uint,
        62i32 as c_uint,
        89i32 as c_uint,
        91i32 as c_uint,
        97i32 as c_uint,
        12i32 as c_uint,
        13i32 as c_uint,
        18i32 as c_uint,
        29i32 as c_uint,
        84i32 as c_uint,
        91i32 as c_uint,
        88i32 as c_uint,
        98i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        29i32 as c_uint,
        93i32 as c_uint,
        95i32 as c_uint,
        95i32 as c_uint,
        98i32 as c_uint,
        97i32 as c_uint,
        20i32 as c_uint,
        26i32 as c_uint,
        84i32 as c_uint,
        88i32 as c_uint,
        95i32 as c_uint,
        95i32 as c_uint,
        98i32 as c_uint,
        94i32 as c_uint,
        26i32 as c_uint,
        86i32 as c_uint,
        91i32 as c_uint,
        93i32 as c_uint,
        97i32 as c_uint,
        99i32 as c_uint,
        98i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        100i32 as c_uint,
        98i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        97i32 as c_uint,
        97i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        99i32 as c_uint,
        97i32 as c_uint,
        99i32 as c_uint,
    ],
    [
        10i32 as c_uint,
        12i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        26i32 as c_uint,
        38i32 as c_uint,
        57i32 as c_uint,
        86i32 as c_uint,
        12i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        28i32 as c_uint,
        35i32 as c_uint,
        41i32 as c_uint,
        54i32 as c_uint,
        76i32 as c_uint,
        14i32 as c_uint,
        21i32 as c_uint,
        25i32 as c_uint,
        32i32 as c_uint,
        44i32 as c_uint,
        63i32 as c_uint,
        92i32 as c_uint,
        136i32 as c_uint,
        19i32 as c_uint,
        28i32 as c_uint,
        32i32 as c_uint,
        41i32 as c_uint,
        54i32 as c_uint,
        75i32 as c_uint,
        107i32 as c_uint,
        157i32 as c_uint,
        26i32 as c_uint,
        35i32 as c_uint,
        44i32 as c_uint,
        54i32 as c_uint,
        70i32 as c_uint,
        95i32 as c_uint,
        132i32 as c_uint,
        190i32 as c_uint,
        38i32 as c_uint,
        41i32 as c_uint,
        63i32 as c_uint,
        75i32 as c_uint,
        95i32 as c_uint,
        125i32 as c_uint,
        170i32 as c_uint,
        239i32 as c_uint,
        57i32 as c_uint,
        54i32 as c_uint,
        92i32 as c_uint,
        107i32 as c_uint,
        132i32 as c_uint,
        170i32 as c_uint,
        227i32 as c_uint,
        312i32 as c_uint,
        86i32 as c_uint,
        76i32 as c_uint,
        136i32 as c_uint,
        157i32 as c_uint,
        190i32 as c_uint,
        239i32 as c_uint,
        312i32 as c_uint,
        419i32 as c_uint,
    ],
    [
        7i32 as c_uint,
        8i32 as c_uint,
        10i32 as c_uint,
        14i32 as c_uint,
        23i32 as c_uint,
        44i32 as c_uint,
        95i32 as c_uint,
        241i32 as c_uint,
        8i32 as c_uint,
        8i32 as c_uint,
        11i32 as c_uint,
        15i32 as c_uint,
        25i32 as c_uint,
        47i32 as c_uint,
        102i32 as c_uint,
        255i32 as c_uint,
        10i32 as c_uint,
        11i32 as c_uint,
        13i32 as c_uint,
        19i32 as c_uint,
        31i32 as c_uint,
        58i32 as c_uint,
        127i32 as c_uint,
        255i32 as c_uint,
        14i32 as c_uint,
        15i32 as c_uint,
        19i32 as c_uint,
        27i32 as c_uint,
        44i32 as c_uint,
        83i32 as c_uint,
        181i32 as c_uint,
        255i32 as c_uint,
        23i32 as c_uint,
        25i32 as c_uint,
        31i32 as c_uint,
        44i32 as c_uint,
        72i32 as c_uint,
        136i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        44i32 as c_uint,
        47i32 as c_uint,
        58i32 as c_uint,
        83i32 as c_uint,
        136i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        95i32 as c_uint,
        102i32 as c_uint,
        127i32 as c_uint,
        181i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        241i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
        255i32 as c_uint,
    ],
    [
        15i32 as c_uint,
        11i32 as c_uint,
        11i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        19i32 as c_uint,
        25i32 as c_uint,
        32i32 as c_uint,
        11i32 as c_uint,
        13i32 as c_uint,
        10i32 as c_uint,
        10i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        19i32 as c_uint,
        24i32 as c_uint,
        11i32 as c_uint,
        10i32 as c_uint,
        14i32 as c_uint,
        14i32 as c_uint,
        16i32 as c_uint,
        18i32 as c_uint,
        22i32 as c_uint,
        27i32 as c_uint,
        12i32 as c_uint,
        10i32 as c_uint,
        14i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        24i32 as c_uint,
        28i32 as c_uint,
        33i32 as c_uint,
        15i32 as c_uint,
        12i32 as c_uint,
        16i32 as c_uint,
        21i32 as c_uint,
        26i32 as c_uint,
        31i32 as c_uint,
        36i32 as c_uint,
        42i32 as c_uint,
        19i32 as c_uint,
        15i32 as c_uint,
        18i32 as c_uint,
        24i32 as c_uint,
        31i32 as c_uint,
        38i32 as c_uint,
        45i32 as c_uint,
        53i32 as c_uint,
        25i32 as c_uint,
        19i32 as c_uint,
        22i32 as c_uint,
        28i32 as c_uint,
        36i32 as c_uint,
        45i32 as c_uint,
        55i32 as c_uint,
        65i32 as c_uint,
        32i32 as c_uint,
        24i32 as c_uint,
        27i32 as c_uint,
        33i32 as c_uint,
        42i32 as c_uint,
        53i32 as c_uint,
        65i32 as c_uint,
        77i32 as c_uint,
    ],
    [
        14i32 as c_uint,
        10i32 as c_uint,
        11i32 as c_uint,
        14i32 as c_uint,
        19i32 as c_uint,
        25i32 as c_uint,
        34i32 as c_uint,
        45i32 as c_uint,
        10i32 as c_uint,
        11i32 as c_uint,
        11i32 as c_uint,
        12i32 as c_uint,
        15i32 as c_uint,
        20i32 as c_uint,
        26i32 as c_uint,
        33i32 as c_uint,
        11i32 as c_uint,
        11i32 as c_uint,
        15i32 as c_uint,
        18i32 as c_uint,
        21i32 as c_uint,
        25i32 as c_uint,
        31i32 as c_uint,
        38i32 as c_uint,
        14i32 as c_uint,
        12i32 as c_uint,
        18i32 as c_uint,
        24i32 as c_uint,
        28i32 as c_uint,
        33i32 as c_uint,
        39i32 as c_uint,
        47i32 as c_uint,
        19i32 as c_uint,
        15i32 as c_uint,
        21i32 as c_uint,
        28i32 as c_uint,
        36i32 as c_uint,
        43i32 as c_uint,
        51i32 as c_uint,
        59i32 as c_uint,
        25i32 as c_uint,
        20i32 as c_uint,
        25i32 as c_uint,
        33i32 as c_uint,
        43i32 as c_uint,
        54i32 as c_uint,
        64i32 as c_uint,
        74i32 as c_uint,
        34i32 as c_uint,
        26i32 as c_uint,
        31i32 as c_uint,
        39i32 as c_uint,
        51i32 as c_uint,
        64i32 as c_uint,
        77i32 as c_uint,
        91i32 as c_uint,
        45i32 as c_uint,
        33i32 as c_uint,
        38i32 as c_uint,
        47i32 as c_uint,
        59i32 as c_uint,
        74i32 as c_uint,
        91i32 as c_uint,
        108i32 as c_uint,
    ],
];
/* JPEG Annex K
 */
/* flat
 */
/* From http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008
 */
/* Relevance of human vision to JPEG-DCT compression (1992) Klein, Silverstein and Carney.
 * Copied from luma
 */
/* DCTune perceptual optimization of compressed dental X-Rays (1997) Watson, Taylor, Borthwick
 * Copied from luma
 */
/* A visual detection model for DCT coefficient quantization (12/9/93) Ahumada, Watson, Peterson
 * Copied from luma
 */
/* An improved detection model for DCT coefficient quantization (1993) Peterson, Ahumada and Watson
 * Copied from luma
 */
unsafe extern "C" fn jpeg_default_qtables(mut cinfo: j_compress_ptr, mut force_baseline: boolean) {
    let mut quant_tbl_master_idx: c_int = 0i32;
    if 0 != jpeg_c_int_param_supported(cinfo, JINT_BASE_QUANT_TBL_IDX) {
        quant_tbl_master_idx = jpeg_c_get_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX)
    }
    jpeg_add_quant_table(
        cinfo,
        0i32,
        std_luminance_quant_tbl[quant_tbl_master_idx as usize].as_ptr(),
        q_scale_factor[0usize],
        force_baseline,
    );
    jpeg_add_quant_table(
        cinfo,
        1i32,
        std_chrominance_quant_tbl[quant_tbl_master_idx as usize].as_ptr(),
        q_scale_factor[1usize],
        force_baseline,
    );
}
#[no_mangle]
pub unsafe extern "C" fn set_quality_ratings(
    mut cinfo: j_compress_ptr,
    mut arg: *mut c_char,
    mut force_baseline: boolean,
) -> boolean {
    /* default value */
    let mut val: c_float = 75.0f32;
    let mut tblno: c_int = 0;
    let mut ch: c_char = 0;
    tblno = 0i32;
    while tblno < NUM_QUANT_TBLS {
        if 0 != *arg {
            ch = ',' as i32 as c_char;
            if sscanf(
                arg,
                b"%f%c\x00" as *const u8 as *const c_char,
                &mut val as *mut c_float,
                &mut ch as *mut c_char,
            ) < 1i32
            {
                return FALSE;
            }
            if ch as c_int != ',' as i32 {
                return FALSE;
            }
            q_scale_factor[tblno as usize] = jpeg_float_quality_scaling(val) as c_int;
            while 0 != *arg as c_int && {
                let fresh0 = arg;
                arg = arg.offset(1);
                *fresh0 as c_int != ',' as i32
            } {}
        } else {
            q_scale_factor[tblno as usize] = jpeg_float_quality_scaling(val) as c_int
        }
        tblno += 1
    }
    jpeg_default_qtables(cinfo, force_baseline);
    if val >= 90i32 as c_float {
        set_sample_factors(
            cinfo,
            b"1x1\x00" as *const u8 as *const c_char as *mut c_char,
        );
    } else if val >= 80i32 as c_float {
        set_sample_factors(
            cinfo,
            b"2x1\x00" as *const u8 as *const c_char as *mut c_char,
        );
    }
    return TRUE;
}
#[no_mangle]
pub unsafe extern "C" fn set_quant_slots(
    mut cinfo: j_compress_ptr,
    mut arg: *mut c_char,
) -> boolean {
    /* default table # */
    let mut val: c_int = 0i32;
    let mut ci: c_int = 0;
    let mut ch: c_char = 0;
    ci = 0i32;
    while ci < MAX_COMPONENTS {
        if 0 != *arg {
            ch = ',' as i32 as c_char;
            if sscanf(
                arg,
                b"%d%c\x00" as *const u8 as *const c_char,
                &mut val as *mut c_int,
                &mut ch as *mut c_char,
            ) < 1i32
            {
                return FALSE;
            }
            if ch as c_int != ',' as i32 {
                return FALSE;
            }
            if val < 0i32 || val >= NUM_QUANT_TBLS {
                fprintf(
                    stderr,
                    b"JPEG quantization tables are numbered 0..%d\n\x00" as *const u8
                        as *const c_char,
                    NUM_QUANT_TBLS - 1i32,
                );
                return FALSE;
            }
            (*(*cinfo).comp_info.offset(ci as isize)).quant_tbl_no = val;
            while 0 != *arg as c_int && {
                let fresh1 = arg;
                arg = arg.offset(1);
                *fresh1 as c_int != ',' as i32
            } {}
        } else {
            (*(*cinfo).comp_info.offset(ci as isize)).quant_tbl_no = val
        }
        ci += 1
    }
    return TRUE;
}
#[no_mangle]
pub unsafe extern "C" fn set_sample_factors(
    mut cinfo: j_compress_ptr,
    mut arg: *mut c_char,
) -> boolean {
    let mut ci: c_int = 0;
    let mut val1: c_int = 0;
    let mut val2: c_int = 0;
    let mut ch1: c_char = 0;
    let mut ch2: c_char = 0;
    ci = 0i32;
    while ci < MAX_COMPONENTS {
        if 0 != *arg {
            ch2 = ',' as i32 as c_char;
            if sscanf(
                arg,
                b"%d%c%d%c\x00" as *const u8 as *const c_char,
                &mut val1 as *mut c_int,
                &mut ch1 as *mut c_char,
                &mut val2 as *mut c_int,
                &mut ch2 as *mut c_char,
            ) < 3i32
            {
                return FALSE;
            }
            if ch1 as c_int != 'x' as i32 && ch1 as c_int != 'X' as i32
                || ch2 as c_int != ',' as i32
            {
                return FALSE;
            }
            if val1 <= 0i32 || val1 > 4i32 || val2 <= 0i32 || val2 > 4i32 {
                fprintf(
                    stderr,
                    b"JPEG sampling factors must be 1..4\n\x00" as *const u8 as *const c_char,
                );
                return FALSE;
            }
            (*(*cinfo).comp_info.offset(ci as isize)).h_samp_factor = val1;
            (*(*cinfo).comp_info.offset(ci as isize)).v_samp_factor = val2;
            while 0 != *arg as c_int && {
                let fresh2 = arg;
                arg = arg.offset(1);
                *fresh2 as c_int != ',' as i32
            } {}
        } else {
            (*(*cinfo).comp_info.offset(ci as isize)).h_samp_factor = 1i32;
            (*(*cinfo).comp_info.offset(ci as isize)).v_samp_factor = 1i32
        }
        ci += 1
    }
    return TRUE;
}
